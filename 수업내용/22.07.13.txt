# 개발자 선형 대수학을 공부하는게 좋다.
# 각도는 디그리,라디안이 있다. 수학에서는 라디안법을 많이 쓴다.
라디안에서 원은 한바퀴를 돌리면 360도가 나온다. 360도=2파이 180도 = 파이 = 3.14

언리얼에서는 각도  -> 라디안 으로 변환하여  사용한다.
피타고라스 -> 루트 -> sin0,cos0 -> 삼각합수 -> 스칼라
프로그래머를 위한 선형대수(노란책)

# Lvalue / Rvalue
Move는 왜 사용할까
Move를 꼭하지 않아도 괜찮다. 복사도 괜찮다.
따라서 Move는 반드시(Must)가 아니다. 하는 것이 좋을 뿐이지 필수는 아니다.
그래도 Move를 사용하면 속도향상에 도움이 된다.
Move는 복사가 아닌 이동이며, 더이상 사용할 수 없는 변수에 대해 Move를 수행한다.

Move연산자는 &&( Move Semantics : 무브 시멘틱) 두개를 사용하여 파라미터를 받아온다.
	Move는 뒤처리 과정이있다. Move중에 메모리 주소를 가진 포인터들의 메모리 주소를
	nullptr 처리를 해준다. 그래서 const를 붙이진 않는다.

#Rvalue Reference(R밸류 레퍼런스(
대입의 식이 있으면 왼쪽에 있으면 L 오른쪽이면 R이며
L밸류는 메모리 공간에 실제 상주하고 있는 값(Logicag..
R밸류는 Temp(임시값)을 의미한다.
A = 10; 이라고할때 메모리 공간에 실제 상주하는 A 는 L배류이며
식에 임시로 사용하는 10이다.
L밸류는 이동시킬 수 없다. 복사를 해야한다.
함수에서 레퍼런스로 파라미터를 받아와서 기본 2번의 복사가 발생한다.
임시공간에 한번 복사하고 그 임시공간에서 함수로 2번째 복사가 발생한다.

※inline하고 사용 느낌이 비슷한거 같다. inline이 함수의 오버헤드를 없애기 위해 사용하는 부분

std::move
- 깊은 복사보다 얕은 복사가 더 빠르다
- move는 얕은 복사와 메모리 이중 해제 방지 처리를 한다.
- 따라서 기본 복사보다는 move가 더 빠르다
- move는 이후에 사용하지 않는 변수에 대해서 사용해야 한다.
- Rvalue참조는 Rvalue가 아니다. 굳이 따지자면 Lvalue에 가깝다.
- 따라서 Rvalue참조는 Rvalue참조로 초기화 할 수 없다.(Lvalue에 가깝기 때문에)

퍼펙트 포워딩
std::forward() 함수는 Lvalue는 Lvalue로 Rvalue는 Rvalue로 형변환을 시켜준다.
해당 함수는 템플릿 프로그래밍에서 사용하면 유용하다.
템플릿에서 타입을 추론할때 템플릿 특성상 L/R value를 잘못 추론할 수 있다.
참조간의 임시값인지를 판단을 확실하게 해주는 함수이다.
---------------------------------------------------------------------------------------------------
@ STL_vector
# 저장할 데이터가 가변적일 때
# 중간의 삽입/삭제를 한다면 사용 안하는게 좋다.
# 저장할 데이터가 개수가 적거나 빈번하게 검색하지 않을 때 사용하면 좋다.
	저장할 데이터의 개수가 적으면 좋은 것은 capacity 재할당 문제


컨테이너의 사용분류
1.크기 변경 가능
2.중간 삽입 / 삭제
3.순차 접근 가능
4.랜덤 접근 가능

패킷 = 헤드+데이터+테일

@ 연관 컨테이너
기본적으로 연관 컨테이너의 본질은
Key와 Value를 묶어서 데이터를 저장한다.
연관 컨테이너는 기본적으로 데이터를 검색하는데 강점이 있다.
대표적으로 map , set , unordered_map , unordered_set 와 hash_map/hash_set도 존재한다.
key의 중복 허용하는 경우는 multi 붙여준다. multi_map multi_set 등등
unordered가 붙은 Red-Black 트리구조이며, Hash 자료구조가 이용된 애들이다.
연관 컨테이너가 모두 검색 속도가 빠르지만, Red-Black형태로 만들어진 트리가 더 빠르며,
HashTable이 이용된 unordered 자료구조들이 검색에 특화되어있는 만큼 빠르다.
map이 Red-Black 트리 형태로 구현되었으며,
unordered_map이 대표적으로 HashTable이 적용된 자료구조이다.

#map은 언제 사용해야 할까?
- 정렬이 필요하다
- 많은 자료를 저장하고 검색 속도가 중요하다
- 삽입, 삭제가 빈번하지 않다 → 한번에 대량의 자료를 저장하고 검색이 잦은 경우

#Hash
Key ->HashFunction -> bucket ->Index 접근
Key를 해시함수에 넣어 버킷값을 뽑아오고 
버킷값으로 해당 인덱스에 접근하여 데이터에 접근한다.
한번에 많은 자료를 저장하고 검색으로 데이터를 가져오고싶을때 사용한다.
