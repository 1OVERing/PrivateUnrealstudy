@Pair 코딩
  보통 코딩하는사람 - 질문자 와 나눠져서 질문자는 보고 배우며 일을 도와준다.

@Vector
STL에서 지원하는 순차 컨테이너형태의 동적배열클래스 자료구조이다.
std:: 는 이름공간이다. namespace 키워드로 std 라는 이름안에 Vector 클래스가
존재하게 된다. 그래서 std 안의 Vector를 사용할 때는 std:: 를 붙여준다.
STL 지원 컨테이너는 list vector deque unordered_map set 등이 존재한다.
	장점 : 
	배열과의 가장 큰 차이점은 크기가 동적으로 변한다.
	인덱스가 있다면 데이터를 빠르게 접근이 가능하다.
	단점 :
	중간에 데이터 삽입이나 삭제가 없다. 뒤에서 부터 하는게 바람직하다.
	주의사항 :
	저장할 데이터가 개수가 적거나 빈번하게 검색하지 않는다.
	검색을 자주한다면 map이나 set hash_map을 사용하는 것이 좋다.
	
@ L/R value
C에서 있던 문법이며 쉽게 생각하면
Lvalue = 표현식 이후에도 사라지지 않는 값. 이름을 지니는 변수
Rvalue = 표현식 이후에는 사라지는 값. 임시 변수
int A = 10;    A (Lvalue) 10 (Rvalue)

@Move 문법 ( Rvalue 만 가능하다)
밑의 코드를 보면 저 경우 a를 호출하는 과정에서 복사생성자가 호출된다.
이 문제를 해결하기 위해, utility 헤더에서 제공하는 move 함수를 사용한다.
결국 복사생성자가 호출되는 것을 막고 이동생성자를 호출하는 것이기 때문에
따로 구현을 안해놨으면 얕은 복사가 발생할 것이다.
#Move Ex
template <typename T>
void swap(const T& a, const T& b);

@ 스택 vs 힙
스택은 메모리를 쌓을 때 기본적으로 정렬을 하며
힙은 무작위로 메모리를 할당한다. 그래서 스택이 기본적으로 빠르다.

@ 스택 자료구조
Last In First Out 형태, 가장 앞에 데이터가 추가된다.
또한 데이터를 삭제할때 기본적으로 가장 최근에 추가한 데이터부터 제거시킨다.
스택은 고정배열로 만들 수 있으며, 동적배열로 만들수 도 있다.
주로 고정배열을 사용하는데 예를들어 공간의 총 용량이 있는 인벤토리를 생각하면
편하다. 최신에서 가장 오래된 것을 보여주기 위해 가장 적합한 자료구조 형태이다.



3*3 기준 총 조합 수(8가지)를 사용하는 방법.


15	15	15   15
4	8	3    .15
4	5	6    .15
7	2	6    .15
		      .15