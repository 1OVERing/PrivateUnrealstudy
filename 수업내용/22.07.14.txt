@ C++ 프로그래밍 책으로 스터티 그룹을 짜서 해볼 예정이다.
=========================================================================
# Big O Notation (빅O표기법)
- 어떤 함수의 복잡도를 정의하는데 사용하는 한 가지 방식이다.
- 자료집합의 크기가 성장함에 따라 알고리즘의 효율이 어떻게 변화하는지 대략적인 측정하는
   하나의 함수이다.
- 빅O표기법은 O(함수)의 형태로 나타낸다.
- 괄호 안에 함수는 보통 n과c라는 글자를 기반으로 하는 하나의 수식이다.
   여기에 n은 알고리즘의 자료 요소들의 개수이며, C는 하나의 상수를 뜻한다.

c -> log2n -> n -> nlog2n -> n2 -> n3 ->2n

#c
대체로 가장 빠르다.
#log2n
밑이 2인 로그함수
로그 기반 알고리즘은 자료의 크기에 
의존적인 알고리즘들 중에서 가장 효율적인 것으로 간주된다.
#n
n은 선형 함수라고 부른다.
n함수는 자료의 크기가 증가함에 따라 일정한 비율로 계산 시간이 증가한다.
#nlog2n
n보다는 복잡도가 증가한 정도이다.
일반적으로 정렬 알고리즘이 가져야 할 최소한의 복잡도라 여겨진다.
#n2
이 함수부터 복잡한 함수라고 할수 있다.
n2함수는 자료가 증가함에 따라 복잡도가 급격하게 증가하기 때문에 비효율적이다.
어떠한 알고리즘이 O(n2)의 알고리즘을 가지고 있다면, 사용을 안하는게 좋다.
for루프 안에 다른for루프가 중첩된 형태가 일반적인 예다.
#n3
이  함수는n2보다 더 안 좋다.
#2n
2n함수는 흔히 지수 함수라고 부른다. 항목 개수가 1개 증가할 때마다 함수는 2배가 된다.
매우 비효율적이라고 할 수 있다.
=========================================================================
@ 난수

# 정수 난수
주사위는 난수 생성기다. 주사위를 던지면 1-6사이의 정수 난수를 얻는다.
주사위는 각 면이 위를 향할 비율이 모두 일정하다는 특징이 있다.
1이 나올확율,5가 나올 확율은 모두 1/6이다.
이러한 특징을 균등분포(Even Distribution)이라고 한다.

# 프로그램에서 난수 생성하기
프로그램에서 난수를 생성하는 방법은 다양하지만, 진정한 난수를 만드는 방법은 존재하지 않는다.
진정한 난수란 다음의 조건을 만족해야 한다.
1. 분표가 균일해야 한다.
2. 결정론적으로 동작해서는 안된다.
3. 반복되는 패턴이 있으면 안된다.
	여기에서 결정론적(Deterministic)이라는 말은 계산이 가능하다는 뜻이다.
	파이의 경우 각 자리의 숫자는 결정론적이다. 파이의 첫번째 자리는 항상 3이고
	그 다음은 1 그 다음은 4이다.
	하지만 안타깝게도 대부분의 컴포터 기반 난수 생성 알고리즘은 결정론적이다.

@ rand / srand 함수
기본적으로 seed라는 종자값을 주지 않으면 항상 같은 값이 나온다.
하지만 종자값이 계속 같으면 몇번을 돌려도 같은 숫자가 나올것이다.
그래서 보통 seed 값에 시간을 넣어서 매번 다른 숫자가 나오게 하는 것이다.
rand함수는 0에서 RAND_MAX(0x7fff)값 사이의 난수를 생성한다. ( 0x7fff = 32767 )

나머지연산를 이용하여 자신이 원하는 범위 내에서의 값을 받아올 수 있다.

- rand의 결점은 20억 주기의 값이 돌려주지만, 나머지를 이용하면 그 주지가 줄어든다.
- rand 함수가 생성한 수들의 하위 비트에는 패턴이 존재하며, 그 패턴의 주기는 20억보다 훨씬 짧다.
- 나머지는 본질적으로 상위 비트를 자른다. 결과적으로 나머지를 통해 얻은 난수들의 주기는
   원래의 난수들보다 훨씬 그 주기가 짧아지게 된다.
- 이를 해결하려면 상위 비트들을 활용해야 한다.

// 범위가 1-6인 경우.
int x = (rand() % 6) + 1;    // 6으로 나눈 나머지가 0이기 때문에 1을 더해줘야 한다.
// 일반화한 함수. 인자 min과 max는 원하는 범위의 최소값과 최대값. 1-6사이의 범위를 원하는 경우, 1과 6.
int RandomRange(int min, int max)
{ int diff = (max - min) + 1;
  return (rand() % diff) + min; }


@ 비선형 난수 생성
선형 난수는 생성되는 난수들의 발생 비율이 모두 동일하다.
RandomRange 함수에서 0에서 4사이의 값을 생성한다고 할 때 0 에서 4사이의 다섯 가지 수들이 
갖는 발생 비율은 이론적으로 모두 20퍼센트다.
하지만 난수 발생 비율을 다르게 하고 싶은 경우도 있다

#두 난수를 더하는 방법
그래프로 그리면 삼각형의 형태가 나오는 그래프이며,
중간값이 가장 높고 처음값과 마지막값이 나오기가 힘든 상태를 만들 수 있다.
int x = RandomRange(0, 4) + RandomRange(0, 4);

#세 난수를 더하는 방법
위의 삼각형 그래프 보단 조금 더 곡선적인 형태의 그래프가 나온다.
=========================================================================
@  map
@ 그래프
@ set ( 집합 )
map은 Key와 Value를 한 쌍으로 저장하지만, set은 Key만 저장한다.
set도 map과 같이 key의 중복을 허용하지 않는다.
set도 map과 같이 Red-Black Tree 자료구조를 사용한다.
set이 필요한 경우는
 - 정렬이 필요할 때
 - Key가 있는지 없는지 알아야 할때
 - 많은 자료를 저장하고 검색 속도가 중요할때
 - 삽입/삭제가 빈번하지 않을 때 - 한번에 대량의 자료를 저장하고 검색이 잦은 경우
정렬할 때 함수객체/람다(무명함수)로 정렬의 기준을 정해줘야 한다.
=========================================================================
@ 알고리즘 - STL 알고리즘 분류

| 분류 			| 내용 							  |
| 변경 불가 시퀀스 알고리즘 	| find, for_each 등이 있고 대상 컨테이너의 내용을 변경하지 못한다. 	  |
| 변경 가능 시퀀스 알고리즘 	| copy, generate 등이 있으며 대상 컨테이너의 내용을 변경할 수 있다. |
| 정렬 알고리즘 		| sort, merge 등이 있다.					  |
| 수치 알고리즘 		| accumulate 등이 있다.					  |
=========================================================================
@ 변경 불가 시퀸스 알고리즘
	include <algorithm> 에 알고리즘이 모여있다.
 # find
	범위를 주고(컨테이너 비긴/엔드) 특정 value를 찾고 반복자를 반환하며, 실패시 last를 반환한다.
	 # 사용방법
	vector< int > Container;
	find( Container.begin(), Container.end(), 15 ); // 컨테이너에서 15를 찾는다.

# find_if
	find를 사용하면 컨테이너에 있는 데이터중에서 원하는 데이터를 쉽게 검색할 수 있다.
	하지만 find는 컨테이너에 기본형만 저장했을때 사용할 수 있다.( 더 정확하게는 == 연산자 구현
	해야만 사용가능하다.)
	사용자정의 자료형을 저장할 땐 findif를 활용해서  조건자를 추가로 받아서 판단한다.
=========================================================================                       
@ 변경 가능 시퀸스 알고리즘
# generate
- 컨테이너 특정 구간을 원하는 값으로 채우고 싶은 경우가 있다.
- 채울 값이 동일한 값인 경우에는 컨테이너의 assign을 사용하면 되지만, 
   동일하지 않다면 다른 방법을 사용해야 한다.
- 이 때 사용하는 알고리즘이 generate다.

# copy
- copy는 컨테이너와 자료형이 같은 다른 컨테이너에 복사를 할 때 사용한다.
- 컨테이너 A의 데이터를 컨테이너 B에 copy하는 경우, 컨테이너 B에 데이터를 추가하는 것이 아니고 
   덮어쓰는 것이기 때문에 A에서 10개를 복사하려면 B에는 10개를 저장할 수 있는 공간이 확보돼야 한다.
- 또한 A와 B 컨테이너는 같은 컨테이너일 필요는 없지만 저장하는 자료형은 같아야 한다.

# remove
- remove는 컨테이너에 특정 값을 삭제하고 싶을 때 사용한다.
- 삭제 후 크기가 변하지 않는다는 점에 주의해야 한다.
- 삭제에 성공하면 삭제 대상이 아닌 데이터들을 앞으로 옮기고, 마지막 위치(컨테이너의 end()가 아닌 
   삭제 후 빈 공간에 다른 데이터를 쓰기 시작하는 위치)를 가리키는 반복자를 반환한다.
- 데이터 삭제 후 공간까지 삭제를 원한다면 erase를 사용해야 한다.

# replace
- 컨테이너의 특정 값을 다른 값으로 변경하려고 할 때 replace를 사용한다.
=========================================================================
@ 정렬 알고리즘
# sort
- sort는 컨테이너에 있는 데이터를 올림차순이나 내림차순으로 정렬할 때 자주 사용한다.
- 컨테이너에 저장된 데이터가 기본형이라면 STL의 less나 greater 비교 조건자를 사용한다.
- 기본형이 아니라면 비교 조건자를 직접 만들어 제공해야 한다.

# binary_search
- 이미 정렬된 컨테이너에서 특정 데이터가 지정한 구간 안에 있는지 검색하는 알고리즘이다.
- sort와 비슷하게 비교 조건자가 필요없는 버전과 필요한 버전이 제공된다.
- sort와는 다르게 랜덤 접근 반복자가 없는 컨테이너에도 사용할 수 있다.

# merge
- 두 개의 정렬된 범위를 합칠 때 사용한다.
- 두 범위와 겹치지 않은 곳에 합친 결과를 넣어야 한다.

=========================================================================
@ 수치 알고리즘
# accumulate
- 지정한 범위에 속한 모든 값을 계산한다.
- 기본적으로는 더하기 연산을 수행하지만, 조건자를 사용해 다른 연산도 수행할 수 있다.
- <numeric> 헤더 파일을 포함시켜야 사용할 수 있다.

# inner_product
- 내적을 수행한다.
- 입력된 두 시퀀스 컨테이너에서 같은 위치의 값을 서로 곱한 값을 모두 더한다.
- 두 번째 시퀀스 컨테이너는 첫 번째 시퀀스 컨테이너 구간보다 크거나 같아야 한다.


=========================================================================

# 시리얼라이제이션 - 직렬화
	Seralization
 객체 -> 저장 포맷(binary - xml - json)
# 디시리얼라이제이션 - 역직렬화
	Deseralization
 객체 -> 저장 포맷 읽어오기 (binary - xml - json)



# 미적분학 - 공간 적분 - 쿼터니언( 사원수 )
