비트 ( Bit )
0 또는 1을 저장할 수 있는 데이터
진법 -> 2진법
우리는 10진법을 사용한다

워드 ( Word )
4 Bit을 하나로 묶은 데이터

바이트 ( Byte )
8 Bit을 하나로 묶은 데이터

RAM ( Random Access Memory )
  º CPU가 자료를 저장하는 공간 ( 실제 하드웨어 )
  º 공간을 일정 크기로 나눠서 사용한다.
      º 32Bit -> 32비트로 나눈다
      º 64Bit -> 64비트로 나눈다
      º 데이터를 점프해서 가져온다.
ROM ( Read Only Memory )
  º 읽기만 하는 메모리
  º 데이터를 순차적으로 읽어서 가져온다.


CPU가 n번지 메모리에 있는 데이터를 RAM이 CPU에게 보내준다.

레퍼런스는 포인터와 기능적으로 똑같지만 레퍼런스는 문법적으로 안전장치가
걸린다.
포인터 같은 경우 역참조를 하지 않는 상태에서는 기본적으로 메모리 주소를 가지고
있는데 이는 실수로 변경하거나 훼손될 가능성이 존재한다. 따라서
레퍼런스가 조금 더 문법적으로 보안장치가 존재한다고 설명할 수 있다.
레퍼런스는 함수 인자를 작성할때 많이 사용된다
Log(const std::string& message)

@Ranged Loop
for문의 배열을 전체 돈다.
for (const int& i : iarr)
{
	std::cout << i << std::endl;
}

힙 ( Heap ) = 자유 저장소
힙은 메모리공간의 할당/반환을 전부 사용자가 해야된다.
만약 반환하지 않는다면 누수가 발생한다.(릭이 남는다)

메모리 할당 관리자 ( Memory allocator )
메모리를 할당시킨 메모리를 관리해주는 녀석
자체적으로 구현시켜 적용해야한다.
보통 레퍼런스카운트를 만들어 참조 횟수를 증감/감소 시켜 자동으로 관리하게 만든다.

struct 와 class
struct(구조체)는 데이터를 묶을 때 사용하자
class(클래스)는 물체를 만들 때 사용하자 라는 암묵적 룰이 존재한다.
초기 전급제한자 설정 외둘다 기능상 차이는 없다.

파스칼 케이스( 이름 규칙 )
대문자로 시작해서 연속되는 단어의 첫글자를 대문자로 이어가는 방식
주로 클래스 이름/ 함수 이름을 작성할때 사용된다.

캐멀 케이싱 ( Camel Casing )
MoveComponent( 파스칼케이스 )
moveComponent( 캐멀 케이싱 )
move_component( 언더바 )
이름의 규칙은 없지만 협업에 도움을 주는 규칙이다.


virtual ( 가상 ) 함수
상위클래스에서 정의된 함수를 하위 클래스에서
오버라이드( 재정의 )를 하면 함수 호출시 하위의 재정의된 함수가 호출된다.
각 객체마다의 다형성을 증가한다.
virtual 함수와 override 함수가 모두 올라가고 나중에 함수를 호출했을 때에
가상함수테이블에서 함수를 찾아서 호출해준다.