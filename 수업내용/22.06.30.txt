@시프트연산
A = A << n ( A의 2진법상 숫자를 왼쪽으로 n번 옮기고 뒤를 0으로 채운다.

@상속관계의 생성자/소멸자
생성시 부모 - 자식
소멸시 자식 - 부모 로 가야하지만
다향성으로 인해 자식클래스를 부모클래스에 넣었을 때
소멸시 해당 변수의 클래스는 부모클래스이기에 소멸시 부모클래스만 소멸자가
호출된다. 그래서 소멸자에 virtual을 붙여줘 자식의 클래스의 소멸자도 호출되게
만들어준다.

@초기화 - Intialization ( 인칠리제이션 )
생성자에 Member Intializer (  멤버 이니셔라이션 ) 를 사용하여
꼭 초기화를 해주자.

@Operator Overloading ( 연산자 오버로딩 )
연산자 ( operator )를 원하는 기능으로 전환해 함수처럼 사용할 수 있도록 해준다.
std:: 안의 cout,cin에 사용하는 << >> 같은 경우 std::stream 형태로 오버로딩 해야한다.
std::ostream& operator<<(std::ostream& stream, const vector2& other)
{  stream << other.x << ',' << other.y << std::endl;
   return stream;  }

@auto
컴파일 타임(시점) 때 타입(type,형)을 결정한다.
auto를 사용하면 변수를 정의할 때 명시적으로 타임을 지정하지 않아도 된다.
변수를 초기화할 때 초기값에 따라 자동으로 타입을 결정해 줌
auro는 지역변수만 사용이 가능하며 클래스의 
멤버 변수,전역 변수, 함수의 인자로는 사용할 수 없다.

@lambda (람다)
람다()는 '람다 함수' 또는 '무명 함수'라고 부르며 성격은 함수 객체와 같다.
C++에서 STL의- find_if, soft 등의 알고리즘을 사용할 때 특정 조건자를 사용하려면
함수 객체를 정의해야 했는데, 람다를 사용하면 손쉽게 필요한 조건자 작성이 가능하다.
[]  // lambda capture - 캡처는 람다 외부에 정의 되어있는 변수를 람다 안에서 사용하고
		     싶을 때 챕처 안에서 명시하여 사용한다.
		     &를 넣으면 전부 참조로 받아온다. ( 전부 참조 )
		     =를 넣으면 전부 복사로 받아온다. ( 전부 복사 )
		     복사해오고 싶으면 변수 이름을 넣어준다.
()  // 함수 정의
{}  // 함수 본문
(); // 함수 호출
char chA = 'A';
char chB = 'B';
auto function = [&,chB] (int num) {std::cout << "Hello world" << num << chA << chB << std::endl; };
function(1);
이런식으로 함수를 객체화 시킬 수 있다.

@ String
char = 1byte / wchar_t(L) = 2byte / char16_t(u) = 2byte / char32_t(U) = 4byte

@ 스택/힙 자료구조
스택이 힙보다 속도가 빠르다.
스택의 에서 공간을 잡는데 메모리의 용량을 넘어서면 스택 오버플로우가 발생한다.
그래서 게임헤서 실제 게임에서 메모리풀을 2GB 등 크게 잡아두고 재활용하여 사용한다.
스택에는 스택포인터라는 포인터를 가지는데 프로그램에서 포인터 연산이 매우 빠르다.

@ 업캐스팅
업캐스팅은 부모 클래스의 포인터로 자식클래스 객체를 가리키는 것이다.
얘를 들어 게임상의 Object를 상속받는 Monster 와 Player 가 존재할 경우
관리를 할 경우 Monster 따로 Player 따로 보관 및 관리를 할 수 있지만,
Object* 로 자료구조(vector,map,list 같은)로 묶어 한대 모아 관리할 수 있다.
@ 다운캐스팅
다운캐스팅은 동일한 타입의 포인터가 동일한 타입을 가르키는 것이다.
업캐스팅 같은 경우 부모클래스에 정의된 멤버만 호출하기에 자식클래스 고유의
기능을 사요할 수 없다. 이때 다운캐스팅을 해서
부모클래스포인터 -> 자식클래스객체의 업캐스팅 형식에서
자식클래스포인터 -> 자식클래스객체로 변환해서 사용한다. 이때 자식클래스는
서로 동일한 타입이여야 한다.
즉 업캐스팅 해서 받아온 포인터를 다운클래스로 변환(자식클래스의 암묵적 형변환)을 통해
자식클래스의 객체 및 함수를 사용할 수 있다.

@Vector
동적배열 이며 Array list 라고 부르기도 한다.
삽입,삭제,잡근 연산이 모두 index에 의해 이뤄지게 된다.
-벡터의 추상 자료형  (ADT)
	- at(integer i) : index i에 대해서 데이터 값을 반환해준다.
	- set(integer i, object o) : index i의 데이터를 o로 바꿔준다.
	- insert/pushback(integer i, object o) : index i에 o를 삽입한다.
	- earase(integer i) : index i에 있는 데이터를 제거해준다.
	- size() : 벡터의 크기를 반환해준다.
	- empty() : 벡터가 비었는지를 알려준다.
