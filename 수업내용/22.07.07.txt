@ List
STL에서 지원하며, Double Linked List라는 자료구조를 이용하여 만든
Sequence Container이다.
Duble Linked List의 특징을 거의 그대로 가지고 있으며 linked list 자료구조에 대한 이해가
있어야 알맞는 상황에 알맞게 사용할 수 있다.
- 고정길이인 배열과 달리 길이가 가변적이다.
- vector와 달리 데이터의 중간삽입,중간삭제 속도가 빠르다.
- 데이터 중간 삽입/삭제시 데이터의 개수에 상관없이 동일한 상수시간이 소요된다.
- list의 순회속도는 O(n), 즉 데이터의 개수가 많을 수록 순회속도가 느리다.
- 각 노드는 앞쪽, 뒤쪽 노드와 연결된 Double Linked List(이중 연결 리스트)이다.
	( 반대는 std::forward_list로써,단일 연결 리스트이다)
사용시 좋은 경우
저장할 데이터의 개수가 가변적일때
저장된 요소를 자주 검색하지 않을때
중간에 데이터 삽입,삭제가 자주 발생할때
랜덤 엑세스를 자주 안할때

@ forward_list
STL에서 지원하면 list 헤더로 사용이 가능하다.
Double Linked list인 std::list와는 다르게 단일 연결 리스트이다.


D2Coding 코드 폰트 변경

@ 함수 포인터

@ std::string / std::wstring
substr/find


@Array / BitArray

@FORCEINLINE (__forceinline)
	#inline
	inline 키워드는 함수 호출 시 발생하는 오버헤드를 줄이기 위해 사용된다.
	함수를 호출하는 대신 함수가 호출된 곳마다 함수의 코드를 복사해 넣어주는 방법이다.

	#오버헤드란 무엇인가?
	오버헤드(Overhead)는 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말한다.
	예를 들어 A라는 처리를 단순하게 실행한다면 10초 걸리는데,
	안전성을 고려하고 부가적인 B라는 처리를 추가한 결과 처리시간이 15초 걸렸다면,
	오버헤드는 5초가 된다. 또한 이 처리 B를 개선해 B'라는 처리를 한 결과, 처리시간이 12초가 되었다면,
	이 경우 오버헤드가 3초 단축되었다고 말한다

	 함수가 호출되는 과정을 요약하면
		1. 함수의 인자를 스택에 저장
		2. 함수가 리턴될 때 돌아올 주소를 스택이나 레지스터에 저장
		3. 함수의 시작 주소로 점프
		4. 함수의 코드 실행
		5. 함수에서 만들어지는 지역변수,스택에 저장된 인자 해제, 리턴값을 레지스터에 저장
		6. 함수를 호출 할 때 저장해둔 주소로 돌아감
	위의 과정을 거치는데 간단한 함수를 호출하기 위해서 저런 명령어들을 수행해야 한다면
	오버헤드가 될 수밖에 없다. 이런 오버헤드를 줄이기 위해서 inline이라는 키워드를 제공한다.
	
	함수 호출 과정 없이 코드를 그대로 복제하여 넣어주므로 속도가 더 빠르다.
	#inline 주의사항	
	코드를 그대로 복제해야 하는 만큼 실행파일의 크기가 커지는 단점이 있다.
	또한 inline 키워드는 권장 사항일 뿐 컴파일러는 프로그래머가 inline 키워드를 선언해도 자유롭게
	무시할 수 있다. ( 긴 함수를 inline화 하려고 하면 무시할 가능성이 있다.
	반대로 프로그래머가 inline을 선언을 안해도 컴파일러가 성능을 위해 inline화 시킬 수도 있다.

__forceinline 키워드는 컴파일러의 비용/이익 분석을 무시하고 프로그래머의 판단에 의존한다.
그렇기에 무분별한 사용은 코드가 커지고 성능 향상은 미미할 수 있다.
